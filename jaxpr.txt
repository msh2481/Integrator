{ lambda ; a:f32[] b:f32[3]. let
    c:f32[3] = pjit[
      name=get_dxdt
      jaxpr={ lambda ; d:f32[] e:f32[3]. let
          f:f32[] = div d 10.0
          g:f32[] = sin f
          h:f32[] = mul g 10.0
          i:f32[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] e
          j:f32[] = squeeze[dimensions=(0,)] i
          k:f32[] = convert_element_type[new_dtype=float32 weak_type=False] h
          l:f32[] = sub k j
          m:f32[] = mul l 0.5
          n:f32[1] = slice[limit_indices=(3,) start_indices=(2,) strides=None] e
          o:f32[] = squeeze[dimensions=(0,)] n
          p:f32[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] e
          q:f32[] = squeeze[dimensions=(0,)] p
          r:f32[] = sub o q
          s:f32[] = mul r 0.20000000298023224
          t:f32[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] e
          u:f32[] = squeeze[dimensions=(0,)] t
          v:f32[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] e
          w:f32[] = squeeze[dimensions=(0,)] v
          x:f32[] = sub u w
          y:f32[] = mul x 0.05000000074505806
          z:f32[] = add s y
          ba:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] m
          bb:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] z
          bc:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] 0.0
          bd:f32[3] = concatenate[dimension=0] ba bb bc
        in (bd,) }
    ] a b
  in (c,) }
