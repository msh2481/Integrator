{ lambda ; a:f32[] b:f32[4]. let
    c:f32[4] = pjit[
      name=jax_dxdt
      jaxpr={ lambda ; d:f32[] e:f32[4]. let
          f:f32[] = sin d
          g:f32[] = mul f 10.0
          h:f32[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] e
          i:f32[] = squeeze[dimensions=(0,)] h
          j:f32[] = convert_element_type[new_dtype=float32 weak_type=False] g
          k:f32[] = sub j i
          l:f32[] = mul k 10.0
          m:f32[1] = slice[limit_indices=(4,) start_indices=(3,) strides=None] e
          n:f32[] = squeeze[dimensions=(0,)] m
          o:f32[1] = slice[limit_indices=(3,) start_indices=(2,) strides=None] e
          p:f32[] = squeeze[dimensions=(0,)] o
          q:f32[] = sub n p
          r:f32[] = mul q 0.5
          s:f32[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] e
          t:f32[] = squeeze[dimensions=(0,)] s
          u:f32[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] e
          v:f32[] = squeeze[dimensions=(0,)] u
          w:f32[] = sub t v
          x:f32[] = mul w 0.10000000149011612
          y:f32[] = add r x
          z:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] l
          ba:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] y
          bb:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] 0.0
          bc:f32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] 0.0
          bd:f32[4] = concatenate[dimension=0] z ba bb bc
        in (bd,) }
    ] a b
  in (c,) }
